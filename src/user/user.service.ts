import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  Logger,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { isBoolean, isDate, isString } from 'class-validator';
import { paginationResult } from 'src/common/filter/pagination';
import { In, Like, Repository } from 'typeorm';
import { NewUserRoleDto } from './dto/new-user-role.dto';
import { UpdateUserProfileDto } from './dto/update-user-profile.dto';
import { UpdateUserRoleDto } from './dto/update-user-role.dto';
import { UserFilterDto } from './dto/user.filter.dto';
import { RoleSection, UserRole } from './entity/user-role.entity';
import { User } from './user.entity';
import { ConfigService } from '@nestjs/config';
import { CreateUserDto } from './dto/create-user.dto';
import { generateUsername } from 'unique-username-generator';
import { v4 as uuid } from 'uuid';
@Injectable()
export class UserService {
  private readonly logger: Logger = new Logger();
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(UserRole)
    private readonly userRoleRepository: Repository<UserRole>,
    // private readonly inboxService: InboxService,
    private readonly config: ConfigService,
  ) {}
  createAllRole(user: User, section: RoleSection) {
    const role = this.userRoleRepository.create({ section, user });
    role.all();
    return role;
  }
  async createRootAdmin() {
    const username = this.config.get<string>('ROOT_USERNAME');
    const email = this.config.get<string>('ROOT_EMAIL');
    const password = this.config.get<string>('ROOT_PASSWORD');
    const firstName = this.config.get<string>('ROOT_FIRSTNAME');
    const lastName = this.config.get<string>('ROOT_LASTNAME');
    const rootObject = {
      username,
      email,
      password,
      firstName,
      lastName,
    };
    let rootUser: User = await this.userRepository.findOne({
      select: ['id', 'username', 'password'],
      where: { username },
    });
    if (rootUser) {
      rootUser.password = rootObject.password;
      await rootUser.hashPassword();
      rootUser = await this.userRepository.save({
        ...rootObject,
        id: rootUser.id,
        password: rootUser.password,
      });
    } else {
      rootUser = this.userRepository.create(rootObject);
      rootUser = await this.userRepository.save(rootUser);
    }
    await this.verfiyUser(rootUser);

    this.userRoleRepository.delete({
      user: rootUser,
    });

    const main = this.createAllRole(rootUser, RoleSection.MAIN);
    const user = this.createAllRole(rootUser, RoleSection.USER);
    const role = this.createAllRole(rootUser, RoleSection.ROLE);
    const category = this.createAllRole(rootUser, RoleSection.CATEGORY);
    const forum = this.createAllRole(rootUser, RoleSection.FORUM);
    const topic = this.createAllRole(rootUser, RoleSection.TOPIC);
    const post = this.createAllRole(rootUser, RoleSection.POST);
    await this.userRoleRepository.save([
      main,
      user,
      category,
      role,
      forum,
      topic,
      post,
    ]);

    this.logger.verbose(`User admin Generated by username ${username}`);
  }
  private async verfiyUser(user: User) {
    await this.userRepository.update(user.id, {
      verificationCode: null,
      verifyed: true,
    });
    return user;
  }
  async createUser(createUserDto: CreateUserDto) {
    const username = generateUsername();
    const password = uuid();
    let user = this.userRepository.create({
      username,
      email: createUserDto.email,
      password,
    });
    user = await this.userRepository.save(user);
    user = await this.verfiyUser(user);

    // await this.inboxService.createInbox(user);

    return {
      user,
      password,
    };
  }
  async getUserById(
    userId: string,
    role: boolean = false,
    details = true,
  ): Promise<User> {
    const user = await this.userRepository.findOne({
      select: [
        'id',
        'username',
        'email',
        'createAt',
        'firstName',
        'lastName',
        'verifyed',
        'bio',
        'birthDate',
        'avatar',
      ],

      where: { id: userId },
      relations: role ? ['roles'] : [],
    });

    if (user && details) {
      await user.detaolsCounting();
    }
    return user;
  }
  async getUsersByFilter(filterDto: UserFilterDto) {
    const where: any[] = [];

    if (filterDto.search) {
      const username = Like(`%${filterDto.search}%`);
      const email = Like(`%${filterDto.search}%`);
      const lastName = Like(`%${filterDto.search}%`);
      const firstName = Like(`%${filterDto.search}%`);
      where.push({ username });
      where.push({ email });
      where.push({ lastName });
      where.push({ firstName });
    }

    const result = await this.userRepository.findAndCount({
      where,
      relations: ['roles'],
      skip: filterDto.offset,
      take: filterDto.limit,
    });

    return paginationResult(result[0], result[1], filterDto);
  }
  async getUserByFilterRole(filterDto: UserFilterDto) {
    filterDto.search = filterDto.search ?? '';

    const query = await this.userRoleRepository
      .createQueryBuilder('r')
      .leftJoinAndSelect('r.user', 'u')
      .where(
        `(
          u.username LIKE :search OR 
          u.email LIKE :search OR 
          u.firstName LIKE :search OR 
          u.lastName LIKE :search
        )`,
        {
          search: `%${filterDto.search}%`,
        },
      );

    const multipleRoleQuery = filterDto.roles
      .map((role) => {
        const keys = Object.keys(role);
        if (keys.length == 0) return '';
        const roleQueryStr = keys
          .map((k) => {
            if (k == 'section') {
              return `(r.${k} = '${role[k]}')`;
            }
            return `(r.${k} = ${role[k]})`;
          })
          .join(' AND ');

        return `(${roleQueryStr})`;
      })
      .join(' OR ');

    if (multipleRoleQuery) query.andWhere(`(${multipleRoleQuery})`);

    const res: any[] = await query.select('u.id').distinct(true).execute();
    const resCountRel: any[] = await this.userRoleRepository
      .createQueryBuilder('r')
      .select('r.user')
      .distinct(true)
      .execute();

    const userIds = res.map((d) => d.u_id);
    const result = await this.userRepository.findByIds(userIds, {
      relations: ['roles'],
      skip: filterDto.offset,
      take: filterDto.limit,
    });

    return paginationResult(result, resCountRel.length, filterDto);
  }
  async updateUser(userId: string, data: any) {}

  async addUserRole(userId: string, author: User, newUserRole: NewUserRoleDto) {
    const user = await this.getUserById(userId);
    const existUserRole = await this.userRoleRepository.findOne({
      where: {
        section: newUserRole.section,
        user,
      },
    });
    if (existUserRole) {
      return this.updateUserRole(existUserRole.id, newUserRole);
    }
    const userRole = this.userRoleRepository.create({
      author,
      user,
      ...newUserRole,
    });

    return await this.userRoleRepository.save(userRole);
  }
  async getRoleById(roleId: string) {
    const userRole = await this.userRoleRepository.findOne({
      where: { id: roleId },
    });
    if (!userRole) {
      throw new NotFoundException(`Role by Id #${roleId} Not Found`);
    }
    return userRole;
  }
  async updateUserRole(roleId: string, updateUserRole: UpdateUserRoleDto) {
    const userRole = await this.getRoleById(roleId);
    const { canCreate, canDelete, canRead, canUpdate } = updateUserRole;
    userRole.canCreate = isBoolean(canCreate) ? canCreate : userRole.canCreate;
    userRole.canRead = isBoolean(canRead) ? canRead : userRole.canRead;
    userRole.canUpdate = isBoolean(canUpdate) ? canUpdate : userRole.canUpdate;
    userRole.canDelete = isBoolean(canDelete) ? canDelete : userRole.canDelete;

    const result = await this.userRoleRepository.update(roleId, userRole);
    return result.affected ? userRole : null;
  }

  async deleteUserRoles(userId: string, section?: RoleSection[]) {
    const user = await this.getUserById(userId, true);
    const result = await this.userRoleRepository.delete({
      user,
      ...(section ? { section: In(section) } : {}),
    });

    return {
      message: result.affected
        ? 'دسترسی کاربر حذف شد'
        : 'دسترسی کاربر حذف نشده',
      count: result.affected,
    };
  }

  async updateProfile(userId: string, uup: UpdateUserProfileDto) {
    let data: any = {};
    if (isString(uup.username)) data.username = uup.username;
    if (isString(uup.email)) data.email = uup.email;
    if (isString(uup.firstName)) data.firstName = uup.firstName;
    if (isString(uup.lastName)) data.lastName = uup.lastName;
    if (isString(uup.bio)) data.bio = uup.bio;
    if (isString(uup.avatar)) data.avatar = uup.avatar;
    if (isDate(uup.birthDate)) data.birthDate = uup.birthDate;

    const user = await this.userRepository.findOne({
      select: ['id', 'username', 'email'],
      where: {
        id: userId,
      },
    });

    if (user.username != data.username) {
      const existUsername = await this.userRepository.findOne({
        where: { username: data.username },
      });
      if (existUsername)
        throw new BadRequestException(`User ${data.username} already exists`);
    } else {
      delete data.username;
    }
    if (user.email != data.email) {
      const existEmail = await this.userRepository.findOne({
        where: { email: data.email },
      });
      if (existEmail)
        throw new BadRequestException(`Email ${data.email} already exists`);
      if (data.email) {
        data.verificationCode = uuid();
        data.verifyed = false;
      }
    } else {
      delete data.email;
    }

    const result = await this.userRepository.update(userId, data);
    if (!result.affected) {
      return {
        ok: false,
      };
    }

    const updatedUser = await this.getUserById(userId, true, false);
    return {
      ok: true,
      updatedUser,
      emailUpdated: !!data.email,
    };
  }
  async updateOwnPassword(
    userId: string,
    currentPassword: string,
    newPassword: string,
  ) {
    const user = await this.userRepository.findOne({
      select: ['id', 'password'],
      where: {
        id: userId,
      },
    });
    const passwordCorrect = await user.checkPassword(currentPassword);
    if (!passwordCorrect) {
      throw new NotFoundException('رمز عبور شما اشتباه است');
    }

    try {
      user.password = newPassword;
      await this.userRepository.save(user);
      return {
        ok: true,
        message: 'گذرواژه با موفقیت تغییر یافت',
      };
    } catch {
      throw new InternalServerErrorException('گذرواژه تغییر نیافت');
    }
  }
}
